<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scrabble Board</title>
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <style>
        @font-face {
            font-family: 'Eurostile';
            src: url('/static/fonts/eurostile.TTF') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        :root {
            --tile-size: 42px;
            --icon-size: 36px;
            --text-color: white;
            --background-color: #2A6334;  /* Dark green background */
            --cell-color: #3F8E41;   /* Light green foreground */
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: var(--background-color);
            font-family: 'Eurostile', sans-serif;
        }

        /* Classes */
        .blocked {
            pointer-events: none; /* Disables clicks */
        }
        .top-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 20px;
        }
        .container {
            display: flex;
            flex-direction: column;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .bottom-container {
            position: relative;
            display: flex;
            align-items: center;
            margin-top: 20px;
        }
        .game-board, .decorative-board{
            display: grid;
            grid-template-columns: repeat(17, var(--tile-size));
            grid-template-rows: repeat(17, var(--tile-size));
            gap: 3px; /* Space between cells */
            border: 5px solid white; /* White grid lines */
        }
        .game-board {
            position: relative;
            z-index: 2; /* On top of the decorative board */
        }
        .decorative-board {
            position: fixed;
            z-index: 1; /* Behind the tiles board */
        }
        .leader-board {
            display: grid;
            width: 220px;
            height: 300px;
            gap: 10px;
            background-color: var(--cell-color);
            align-items: center;
            align-content: baseline;
            margin: 10px;
            border-radius: 10px;
        }
        .leader-board-table {
            display: grid;
            grid-template-columns: repeat(1, 100%);
            grid-template-rows: repeat(5, var(--tile-size));
            row-gap: 10px;
        }
        .player-item {
            width: auto;
            height: 100%;
            background-color: var(--background-color); /* Dark green background */
            color: var(--text-color);
            align-items: center;
            text-align: center;
            display: flex;
            justify-content: center;
            text-transform: uppercase;
            column-gap: 10px;
            border-radius: 10px;
            margin: 10px;
        }
        .cell, .transparent-cell, .rack-cell, .header-cell {
            display: flex;
            width: var(--tile-size);
            height: var(--tile-size);
            align-items: center;
            justify-content: center;
            font-weight: bold;
            text-transform: uppercase;
            text-align: center;
        }
        .cell {
            font-size: 10px;
            color: #000; /* Black text for all cells */
            background-color: var(--cell-color);
            border: 2px solid transparent;
            box-sizing: border-box;
        }
        .transparent-cell {
            font-size: 9px;
            border: 2px solid transparent;
            box-sizing: border-box;
        }
        .transparent-cell:hover {
            border: 2px solid white;
            cursor: pointer;
        }
        .double-letter {
            background-color: #bad5f1; /* Light Blue */
            color: #000000; /* Black text for better contrast */
        }
        .triple-letter {
            background-color: #52a1e1; /* Dark Blue */
            color: #000000; /* Black text for better contrast */
        }
        .double-word {
            background-color: #e2bd46; /* Yellow */
            color: #000000; /* Black text for better contrast */
        }
        .triple-word {
            background-color: #d43322; /* Red */
            color: #000000; /* Black text for better contrast */
        }
        .center-cell {
            background-color: #e2bd46; /* Yellow */
            font-size: 14px;
        }
        .header-cell {
            background-color: var(--background-color);
            color: white;
            border: 2px solid transparent;
        }
        .header-cell:hover {
            border: 2px solid transparent;
        }
        .rack-container {
            display: flex;
            width: 100%;
            height: auto;
            align-items: center;
            background-color: var(--cell-color);
            grid-template-columns: repeat(3, var(--tile-size));
            grid-template-rows: repeat(1, var(--tile-size));
            gap: 10px; /* Space between cells */
            border-radius: 10px;
            justify-content: space-evenly;
        }
        .rack {
            display: grid;
            z-index: 2;
            justify-content: center;
            align-items: center;
            margin: 20px;
            gap: 10px; /* Space between cells */
            grid-template-columns: repeat(7, var(--tile-size));
            grid-template-rows: repeat(1, var(--tile-size));
            width: fit-content;
            height: fit-content;
        }
        .rack-cell {
            font-size: 9px;
        }
        .tile, .locked-tile {
            display: flex;
            position: relative;
            width: var(--tile-size);
            height: var(--tile-size);
            z-index: 3; /* Behind the tiles board */
            border-radius: 5px;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            user-select: none; /* Disable text selection */
        }
        .tile {
            background-color: #c6ae89;
            box-sizing: border-box;
            border: 2px solid transparent;
            cursor: pointer;
        }
        .dragging-tile{
            position: fixed;
        }
        .tile:hover {
            background-color: #b98a43;
            border: 2px solid white;
        }
        .tile:active {
            background-color: #b88130;
            border: 2px solid white;
            font-weight: bolder;
        }
        .locked-tile {
            margin: 0px;
            background-color: #b88130;

        }
        .tile .points {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 12px;
            font-weight: normal;
            user-select: none; /* Disable text selection */
        }
        .circular-button {
            display: flex;
            width: 40px;
            height: 40px;
            margin: 5px;
            border-radius: 50%; /* Rounded button */
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        .rect-button {
            display: flow-root;
            width: 150px;
            padding: 10px 20px;
            background-color: #ADD8E6; /* Light blue background */
            color: #00008B; /* Dark blue text */
            border: 2px solid white; /* White border */
            border-radius: 5px; /* Slightly rounded corners */
            text-align: center;
            font-weight: bold;
            cursor: pointer;
        }
        .rect-button:hover {
            background-color: #87CEEB; /* Slightly darker blue on hover */
        }

        /* Objects */

        #revertButton {
            background-color: #ADD8E6; /* Light blue background */
            border: 2px solid white; /* White border */
        }
        #revertButton svg {
            width: var(--icon-size);
            height: var(--icon-size);
            fill: #2d425d;
            stroke: none; /* Dark blue color for the logo */
        }
        #revertButton:hover {
            background-color: #87CEEB; /* Slightly darker blue on hover */
        }
        #shuffleButton {
            background-color: #dabf52; /* Light yellow background */
            border: 2px solid white; /* White border */
        }
        #shuffleButton svg {
            width: var(--icon-size);
            height: var(--icon-size);
            fill: #3c361a;
            stroke: none; /* Dark blue color for the logo */
        }
        #shuffleButton:hover {
            background-color: #b69f42; /* Slightly darker yellow on hover */
        }
        #submitButton {
            background-color: green; /* Light blue background */
        }
        #submitButton:hover {
            background-color: lightgreen; /* Light blue background */
        }
        #skipTurnButton {
            background-color: orangered; /* Light blue background */
        }
        #skipTurnButton:hover {
            background-color: orange; /* Light blue background */
        }
        .points-box {
            width: 60px;
            height: 40px;
            padding: 10px 20px;
            align-content: center;
            background-color: var(--cell-color);
            color: var(--text-color);
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
        }
        #returnLobbyButton {
            width: 100px;
            height: 60px;
            background-color: red; /* Light blue background */
            border: 2px solid white; /* White border */
        }
        #returnLobbyButton svg {
            width: var(--icon-size);
            height: var(--icon-size);
            fill: white;
            stroke: none;
        }
        #returnLobbyButton:hover {
            background-color: #f25433; /* Light blue background */
        }

    </style>
</head>
<body>     
    <div class="container" style="display: grid; grid-template-columns: repeat(2, auto); grid-template-rows: repeat(1, auto); align-items: start;">
        <div class="container">
            <div class="top-container">
                <button class="rect-button" id="returnLobbyButton" title="Return to Lobby">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960"><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h280v80H200v560h280v80H200Zm440-160-55-58 102-102H360v-80h327L585-622l55-58 200 200-200 200Z"/></svg>
                </button>
                <div class="points-box" id="pointBox">
                    <span id="myPlayerPoints">0</span>
                </div>
                <div></div>
            </div>
        
            <div class="container">
                <div class="decorative-board" id="decorativeBoard">
                    <script>
                        // Letters for column headers
                        const columnHeaders = ['', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', ''];
                        const rowHeaders = ['', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', ''];
                        
                        // Define special cells with their corresponding full labels
                        const specialCells = {
                            '0,0': { type: 'triple-word', text: 'TRIPLE WORD' },
                            '0,7': { type: 'triple-word', text: 'TRIPLE WORD' },
                            '0,14': { type: 'triple-word', text: 'TRIPLE WORD' },
                            '7,0': { type: 'triple-word', text: 'TRIPLE WORD' },
                            '7,14': { type: 'triple-word', text: 'TRIPLE WORD' },
                            '14,0': { type: 'triple-word', text: 'TRIPLE WORD' },
                            '14,7': { type: 'triple-word', text: 'TRIPLE WORD' },
                            '14,14': { type: 'triple-word', text: 'TRIPLE WORD' },
                            
                            '1,5': { type: 'triple-letter', text: 'TRIPLE LETTER' },
                            '1,9': { type: 'triple-letter', text: 'TRIPLE LETTER' },
                            '5,1': { type: 'triple-letter', text: 'TRIPLE LETTER' },
                            '5,5': { type: 'triple-letter', text: 'TRIPLE LETTER' },
                            '5,9': { type: 'triple-letter', text: 'TRIPLE LETTER' },
                            '5,13': { type: 'triple-letter', text: 'TRIPLE LETTER' },
                            '9,1': { type: 'triple-letter', text: 'TRIPLE LETTER' },
                            '9,5': { type: 'triple-letter', text: 'TRIPLE LETTER' },
                            '9,9': { type: 'triple-letter', text: 'TRIPLE LETTER' },
                            '9,13': { type: 'triple-letter', text: 'TRIPLE LETTER' },
                            '13,5': { type: 'triple-letter', text: 'TRIPLE LETTER' },
                            '13,9': { type: 'triple-letter', text: 'TRIPLE LETTER' },
                            
                            '7,7': { type: 'center-cell', text: '★' },
                            '1,1': { type: 'double-word', text: 'DOUBLE WORD' },
                            '2,2': { type: 'double-word', text: 'DOUBLE WORD' },
                            '3,3': { type: 'double-word', text: 'DOUBLE WORD' },
                            '4,4': { type: 'double-word', text: 'DOUBLE WORD' },
                            '10,10': { type: 'double-word', text: 'DOUBLE WORD' },
                            '11,11': { type: 'double-word', text: 'DOUBLE WORD' },
                            '12,12': { type: 'double-word', text: 'DOUBLE WORD' },
                            '13,13': { type: 'double-word', text: 'DOUBLE WORD' },
                            '1,13': { type: 'double-word', text: 'DOUBLE WORD' },
                            '2,12': { type: 'double-word', text: 'DOUBLE WORD' },
                            '3,11': { type: 'double-word', text: 'DOUBLE WORD' },
                            '4,10': { type: 'double-word', text: 'DOUBLE WORD' },
                            '10,4': { type: 'double-word', text: 'DOUBLE WORD' },
                            '11,3': { type: 'double-word', text: 'DOUBLE WORD' },
                            '12,2': { type: 'double-word', text: 'DOUBLE WORD' },
                            '13,1': { type: 'double-word', text: 'DOUBLE WORD' },
    
                            '0,3': { type: 'double-letter', text: 'DOUBLE LETTER' },
                            '0,11': { type: 'double-letter', text: 'DOUBLE LETTER' },
                            '2,6': { type: 'double-letter', text: 'DOUBLE LETTER' },
                            '2,8': { type: 'double-letter', text: 'DOUBLE LETTER' },
                            '3,0': { type: 'double-letter', text: 'DOUBLE LETTER' },
                            '3,7': { type: 'double-letter', text: 'DOUBLE LETTER' },
                            '3,14': { type: 'double-letter', text: 'DOUBLE LETTER' },
                            '6,2': { type: 'double-letter', text: 'DOUBLE LETTER' },
                            '6,6': { type: 'double-letter', text: 'DOUBLE LETTER' },
                            '6,8': { type: 'double-letter', text: 'DOUBLE LETTER' },
                            '6,12': { type: 'double-letter', text: 'DOUBLE LETTER' },
                            '7,3': { type: 'double-letter', text: 'DOUBLE LETTER' },
                            '7,11': { type: 'double-letter', text: 'DOUBLE LETTER' },
                            '8,2': { type: 'double-letter', text: 'DOUBLE LETTER' },
                            '8,6': { type: 'double-letter', text: 'DOUBLE LETTER' },
                            '8,8': { type: 'double-letter', text: 'DOUBLE LETTER' },
                            '8,12': { type: 'double-letter', text: 'DOUBLE LETTER' },
                            '11,0': { type: 'double-letter', text: 'DOUBLE LETTER' },
                            '11,7': { type: 'double-letter', text: 'DOUBLE LETTER' },
                            '11,14': { type: 'double-letter', text: 'DOUBLE LETTER' },
                            '12,6': { type: 'double-letter', text: 'DOUBLE LETTER' },
                            '12,8': { type: 'double-letter', text: 'DOUBLE LETTER' },
                            '14,3': { type: 'double-letter', text: 'DOUBLE LETTER' },
                            '14,11': { type: 'double-letter', text: 'DOUBLE LETTER' },
                        };
    
                        for (let row = 0; row < 17; row++) {
                            for (let col = 0; col < 17; col++) {
                                if (row == 0) {
                                    const letter = columnHeaders[col];
                                    document.write(`<div class="header-cell">${letter}</div>`);
                                    continue;                       
                                } 
                                else if (row==16) {
                                    const letter = columnHeaders[col];
                                    document.write(`<div class="header-cell">${letter}</div>`);
                                    continue;                       
                                }
                                else {
                                    if (col == 0) {
                                        document.write(`<div class="header-cell">${row}</div>`);
                                        continue;                       
                                    }
                                    else if (col == 16) {
                                        document.write(`<div class="header-cell">${row}</div>`);
                                        continue;                       
                                    }
                                }
    
                                const cellInfo = specialCells[`${row-1},${col-1}`];
                                const cellClass = cellInfo ? cellInfo.type : '';
                                const cellText = cellInfo ? cellInfo.text : '';
                                document.write(`<div class="cell ${cellClass}">${cellText}</div>`);
                            }
                        }
                    </script>
                </div>
                <div class="game-board" id="gameBoard">
                    <!-- Generate the game board cells -->
                    <script>
                        for (let row = 0; row < 17; row++) {
                            for (let col = 0; col < 17; col++) {
                                
                                let cellLocation = '';
                                if (row == 0 || row == 16 || col == 0 || col == 16) {
                                } else {
                                    cellLocation = 'cell_' + `${columnHeaders[col]}` + `${rowHeaders[row]}`
                                }
                                document.write(`<div location="${cellLocation}" class="transparent-cell" data-row="${row+1}" data-col="${col+1}"></div>`);
                            }
                        }
                    </script>
                </div>
            </div>
            
            <div class="bottom-container">
                <div id="rackDiv" style="display: flex; visibility: collapse;">
                    <div class="rack-container">
                        <button class="circular-button" id="shuffleButton" title="Shuffle">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960"><path d="M560-160v-80h104L537-367l57-57 126 126v-102h80v240H560Zm-344 0-56-56 504-504H560v-80h240v240h-80v-104L216-160Zm151-377L160-744l56-56 207 207-56 56Z"/></svg>
                        </button>
                        <div class="rack" id="scrabbleRack"></div>
                        <button class="circular-button" id="revertButton" title="Revert">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960"><path d="m 600,-200 -56,-57 143,-143 H 300 q -75,0 -127.5,-52.5 Q 120,-505 120,-580 120,-655 172.5,-707.5 225,-760 300,-760 h 20 v 80 h -20 q -42,0 -71,29 -29,29 -29,71 0,42 29,71 29,29 71,29 h 387 l -143,-144 56,-56 240,240 z"/></svg>
                        </button>
                    </div>
        
                    <div class="container" style="padding: 10px; margin-left: 50px; margin-top: 10px; margin-bottom: 10px; row-gap: 10px;">
                        <button class="rect-button" id="skipTurnButton" title="Skip Turn">Skip Turn</button>
                        <button class="rect-button" id="submitButton"  title="Submit">Submit <span id="tentativePoints"></span></button>
                    </div>
                </div>
                <div id="playerOrderDiv" style="display: flex; position: absolute; z-index: 10; width: 100%; height: 100%; align-items: center; justify-content: space-around;">
                    <button class="rect-button" id="requestOrderButton" title="Get Tile">Get Tile</button>
                </div>
                <div id="orderTileDiv" style="display: flex;  visibility: collapse; position: absolute; z-index: 11; width: 100%; height: 100%; align-items: center; justify-content: space-around;">
                </div>
            </div>
        </div>
        <div class="leader-board" style="margin-top: 80px;">
            <h1 style="color: var(--text-color); text-align: center;">LEADERBOARD</h1>
            <div class="leader-board-table" id="tableLeaderboard"></div>
        </div>
    </div>
</body>

<script>

//const socket = io.connect('https://127.0.0.1:5000');
const socket = io.connect(`${window.location.origin}`);

const letterPoints = new Map([
    ['A', 1], ['B', 3], ['C', 3], ['D', 2], ['E', 1],
    ['F', 4], ['G', 2], ['H', 4], ['I', 1], ['J', 8],
    ['K', 5], ['L', 1], ['M', 3], ['N', 1], ['O', 1],
    ['P', 3], ['Q', 10], ['R', 1], ['S', 1], ['T', 1],
    ['U', 1], ['V', 4], ['W', 4], ['X', 8], ['Y', 4],
    ['Z', 10], [' ', 0]
]);

const PlayerState = {
    UNDEFINED:      0,   // The player has not been initialized yet
    NOT_READY:      1,   // The player has entered lobby screen but not clicked the ready button yet
    READY:          2,   // After player has clicked the ready button on lobby screen
    WAITING:        3,   // Player is waiting for its next turn to play
    PLAYING:        4,   // Player is playing its turn
    WON:            5,   // Player has won the game
    LOST:           6,   // Player has lost the game
    WAITING_ORDER:  7    // Player is waiting to be ordered 
};

const GameState = {
    UNDEFINED:               0,  // Initial state
    WAITING_FOR_PLAYERS:     1,  // Waiting for players to join the game
    PLAYER_ORDER_SELECTION:  2,  // Players are selecting the order of play
    GAME_STARTED:            3,  // Game has started
    GAME_OVER:               4  // Game is over
}

class Game {
    gameID = '';
    players = [];
    gameState = GameState.UNDEFINED;

    constructor(gameID) {
        this.gameID = gameID;
        this.players = [];
    }

    getGameID() {
        return this.gameID;
    }

    getGameState() {
        return this.gameState;
    }

    setGameState(state) {
        this.gameState = state;
    }

    addPlayers(player) {
        this.players.push(player);
    }
}

class Player {
    playerID = -1;
    playerName = '';
    playerType = 0;
    isAdmin = false;
    playerState = PlayerState.UNDEFINED;
    orderLetter = null;
    points = 0;

    constructor(playerID, playerName) {
        this.playerID = playerID;
        this.playerName = playerName;
    }

    getPlayerID() {
        return this.playerID;
    }

    setPlayerID(playerID) {
        this.playerID = playerID;
    }

    getPlayerName() {
        return this.playerName;
    }

    setPlayerName(playerName) {
        this.playerName = playerName;
    }

    getPlayerType() {
        return this.playerType;
    }

    setPlayerType(playerType) {
        this.playerType = playerType;
    }

    getPlayerState() {
        return this.playerState;
    }

    setPlayerState(playerState) {
        this.playerState = playerState;
    }

    setAdmin() {
        this.isAdmin = true;
    }

    isAdmin() {
        return this.isAdmin;
    }

    getOrderLetter() {
        return this.orderLetter;
    }

    setOrderLetter(letter) {
        this.orderLetter = letter;
    }

    getPoints() {
        return this.points;
    }

    setPoints(points) {
        this.points = points;
    }

}

/** @type {Game} */
let myGame = null;
/** @type {Player} */
let myPlayer = null;
/** @type {number} */
let currentPlayerID = null;
/** @type {Object<string, any>} */
let playersMeta = null;

let selectedTiles = [];
let tileCounter = 0; // Initialize a counter for the tiles

socket.on('update-game', function(data) {
    console.log('update-game::::');
    updateGame(data.gameMeta);
});

socket.on('update-players', function(data) {
    console.log('update-players::::');
    playersMeta = data.playersMeta;
    updatePlayers(data.playersMeta);
});

socket.on('update-board', function(data) {
    console.log('update-board::::');
    updateBoard(data.board);
});

socket.on('update-rack', function(data) {
    console.log('update-rack::::');
    //updateMyRack(data.racks);
});

function getUrlParams() {
    const path = window.location.pathname;
    const pathParts = path.split('/');
    return {
        game_id: pathParts[2],
        player_id: pathParts[3]
    };
}

window.onload = function() {
    const urlParams = getUrlParams();
    const gameID = urlParams.game_id;
    const playerID = urlParams.player_id;

    console.log(`Game ID: ${gameID}`);
    console.log(`Player ID: ${playerID}`);

    // Initialize game and player objects
    myGame = new Game(gameID);

    // Following function also creates myPlayer
    fetchPlayerName(playerID);

    // This will update game window
    // Need to put some delay since socket connections are not properly handled during page load
    setTimeout(requestUpdate, 500);  // 500ms
};

const letterCounts = new Map([
    ['A', 9], ['B', 2], ['C', 2], ['D', 4], ['E', 12],
    ['F', 2], ['G', 3], ['H', 2], ['I', 9], ['J', 1],
    ['K', 1], ['L', 4], ['M', 2], ['N', 6], ['O', 8],
    ['P', 2], ['Q', 1], ['R', 6], ['S', 4], ['T', 6],
    ['U', 4], ['V', 2], ['W', 2], ['X', 1], ['Y', 2],
    ['Z', 1], [' ', 2]
]);

// For debug purposes
/*
{
    let totalTiles = 0;
    letterCounts.forEach((count, letter) => {
        totalTiles += count;
    });

    let myTiles = ['A', 'B', 'C', 'E', 'J', 'K', 'L'];
    const scrabbleRack = document.getElementById('scrabbleRack');

    // Add my tiles to the scrabble rack
    myTiles.forEach((letter) => {
        let points = letterPoints.get(letter);
        const tile = createTile(letter, points);
        scrabbleRack.appendChild(tile);
    });
}
*/

// Create the tile element
function createTile(letter, points, id=-1, location = '') {
    const tile = document.createElement('div');
    tile.classList.add('tile');
    tile.textContent = letter;  // Only the letter is shown on the tile
    tile.setAttribute('location', location); // Set the location attribute
    tile.style.position = 'relative'; 
    
    // If no ID is provided, assign a new one
    if (id === -1) {
        id = tileCounter++;
    }
    tile.setAttribute('tileID', id); // Set the unique identifier attribute

    // Add a span to display the points
    const pointsSpan = document.createElement('span');
    pointsSpan.classList.add('points');
    pointsSpan.textContent = points;
    tile.appendChild(pointsSpan);

    tile.addEventListener('mousedown', mouseDownHandler);
    tile.addEventListener('click', clickHandler);

    return tile;
}

// Drag and Drop functions
/*
function dragOver(event) {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
}

function drop(event) {
    event.preventDefault();

    const letter = event.dataTransfer.getData('text/plain');  // Only the letter
    const points = letterPoints.get(letter);  // Get points based on the letter
    const parentElementHTML = event.dataTransfer.getData('parentElement');  // Get original tile's HTML
    const dropTarget = event.target;

    // Ensure dropTarget is a valid cell on the game board
    if (dropTarget.classList.contains('transparent-cell') && !dropTarget.hasChildNodes()) {
        console.log('Tile dropped successfully');

        // Create a new tile and add it to the drop target
        const tile = createTile(letter, points);
        dropTarget.innerHTML = '';  // Clear the cell
        dropTarget.appendChild(tile);  // Place the tile on the board

        // Now we need to remove the tile from its original location
        const parentDiv = document.createElement('div');
        parentDiv.innerHTML = parentElementHTML;  // Parse the stored HTML
        const myRack = parentDiv.querySelector('.rack');
        const myCell = parentDiv.querySelector('.transparent-cell');

        //if (myRack) {
        //    myRack.removeChild(originalTile.querySelector('.tile'));  // Remove the tile from its original place
        //}
        //if (myCell) {
        //    myCell.removeChild(originalTile.querySelector('.tile'));  // Remove the tile from its original place
        //}
    } else {
        console.log('Invalid drop location. Returning tile to rack.');

        // If not a valid drop, return the tile to the rack
        const tile = createTile(letter, points);  // Create the tile again
        const scrabbleRack = document.getElementById('scrabbleRack');

        scrabbleRack.appendChild(tile);
    }
}
*/

// Mouse event handlers

function mouseDownHandler(event) {
    let tile = event.target;
    if (!tile.classList.contains('tile')) {
        tile = tile.closest('.tile');
    }
    if (tile) {
        tile.classList.add('dragging-tile'); // Add dragging class
        tile.classList.remove('placed-tile'); // Remove placed-tile class

        document.addEventListener('mousemove', mouseMoveHandler);
    }
}

function mouseMoveHandler(event) {
    const tile = document.querySelector('.dragging-tile');
    if (tile) {
        tile.style.position = 'fixed';
        tile.style.left = `${event.pageX+2}px`;
        tile.style.top = `${event.pageY+2}px`;
        tile.style.zIndex = 1000; // Bring the tile to the front
    }
    document.addEventListener('mouseup', mouseUpHandler);
}

function checkBoardZone(target) {
    if (target.classList.contains('transparent-cell')) {
        
        if (target.getAttribute('location')==='') {
            if (target.hasChildNodes()) {
                const child = target.firstChild;
                if (child.classList.contains('dragging-tile')) {
                    return true;
                }
            }
            return false;
        }
        else return true;
    }
    else return false;
}

function mouseUpHandler(event) {
    const tile = document.querySelector('.dragging-tile');

    if (tile) {
        let dropTarget = event.target;

        if (!tile.hasChildNodes()) return;

        const letter = tile.firstChild.textContent; // Only the letter, without any span
        const points = letterPoints.get(letter);  // Get points based on the letter
        const tileID = tile.getAttribute('tileID');
        
        if (tileID === null) {
            tileID = tileCounter++;
        }

        const parentNode = tile.parentNode;

        // Check if the drop target is a tile if it is return the tile to the rack
        if (dropTarget.classList.contains('tile') || !checkBoardZone(dropTarget)) {
            console.log('Place is already occupied. Returning tile to rack.');

            // Remove the original tile from the scrabble rack
            if (parentNode.contains(tile)) {
                parentNode.removeChild(tile);
            }

            const returnTile = createTile(letter, points, tileID);  // Create the tile again
            const scrabbleRack = document.getElementById('scrabbleRack');
            scrabbleRack.appendChild(returnTile);

            removeSelectedTile(tileID);
        } else if (checkBoardZone(dropTarget)) {  // Check if the drop target is a valid cell on the game board
            console.log('Tile placed successfully');

            const cellLocation = dropTarget.getAttribute('location').split('_')[1];

            // Create a new tile and add it to the drop target
            const newTile = createTile(letter, points, tileID, cellLocation);
            dropTarget.innerHTML = '';  // Clear the cell
            dropTarget.appendChild(newTile);  // Place the tile on the board
            
            // Remove the original tile from the scrabble rack
            if (parentNode.contains(tile)) parentNode.removeChild(tile);

            newTile.classList.add('placed-tile'); // Add placed-tile class

            addSelectedTile(letter, tileID, cellLocation);
            verifyWord(selectedTiles);
            
        } else if (dropTarget.classList.contains('rack')) {  // Check if the drop target is the scrabble rack
            console.log('Tile placed rack');

            // Create a new tile and add it to the drop target
            const newTile = createTile(letter, points, tileID);
            dropTarget.appendChild(newTile);  // Place the tile on the board
            
            // Remove the original tile from the scrabble rack
            parentNode.removeChild(tile);

            removeSelectedTile(tileID);
        } else {  // If not a valid drop, return the tile to the rack
            console.log('Invalid drop location. Returning tile to rack.');

            // Remove the original tile from the scrabble rack
            if (parentNode.contains(tile)) {
                parentNode.removeChild(tile);
            }

            const returnTile = createTile(letter, points, tileID);  // Create the tile again
            const scrabbleRack = document.getElementById('scrabbleRack');
            scrabbleRack.appendChild(returnTile);

            removeSelectedTile(tileID);
        }

        tile.classList.remove('dragging-tile'); // Remove dragging-tile class
    }

    document.removeEventListener('mousemove', mouseMoveHandler);
    document.removeEventListener('mouseup', mouseUpHandler);
}

function clickHandler(event) {
    const tile = event.target;
    if (!tile.classList.contains('tile')) {
    }
}

// Add event listeners to board cells
//const boardCells = document.querySelectorAll('.transparent-cell');
//boardCells.forEach(cell => {
//    cell.addEventListener('dragover', dragOver);
//    cell.addEventListener('drop', drop);
//});

function addSelectedTile(letter, tileID, location) {
    const existingTile = selectedTiles.find(t => t.tileID === tileID);
    if (existingTile) {
        // Update the location if the tile is already placed
        existingTile.location = location;
    } else {
        // Add the new tile to the selectedTiles array
        selectedTiles.push({letter, tileID, location});
    }
}

function removeSelectedTile(tileID) {
    selectedTiles = selectedTiles.filter(t => t.tileID !== tileID);
}

function verifyWord(tiles) {
    tiles.forEach((letter, tileID, location) => {
        console.log(letter, tileID, location);
    }); 

    const tilesJson = JSON.stringify(tiles);

    fetch(`${window.location}/verify-word`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: tilesJson
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            // Update the points box with the calculated points
            if (data.points>0) {
                updateTentativePoints(data.points)

                alert('Word verified successfully!');
                return true;
            } else {
                alert('Word verification failed!');
                return false;
            }
        } else {
            alert('Unknown error: ' + data.message);
            return false;
        }
    })
    .catch(error => {
        console.error('Error:', error);
        return false;
    });
}

function fetchPlayerName(playerID) {
    fetch(`${window.location}/get-player-name`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            console.log(data);
            console.log(`Player Name: ${data.playerName}`);
            if (data.playerName !== null) {
                myPlayer = new Player(playerID, data.playerName);
            }
        } else {
            alert('Unknown error: ' + data.message);
        }
    })
    .catch(error => {
        console.error('Error:', error);
    });
}

// User buttons

document.getElementById('returnLobbyButton').addEventListener('click', quitGame);
document.getElementById('requestOrderButton').addEventListener('click', requestOrder);
document.getElementById('revertButton').addEventListener('click', revertTiles);
document.getElementById('shuffleButton').addEventListener('click', shuffleTiles);
document.getElementById('skipTurnButton').addEventListener('click', skipTurn);

document.getElementById('submitButton').addEventListener('click', () => {
    submitWord(selectedTiles);
});

function requestUpdate() {
    console.log('request update...');
    fetch(`${window.location}/request-update`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
    })
    .then(response => response.json())
    .then(data => {})
    .catch(error => {
        console.error('Error:', error);
    });

}

function quitGame() {
    alert('You are about to quit game. Are you sure?');

    fetch(`${window.location}/quit-game`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({'playerID': myPlayer.getPlayerID()})
    })
    .then(response => {
        if (response.redirected) {
            // Handle redirection
            window.location.href = response.url;
        } else {
            return response.json();
        }
    })
    .then(data => {
        // Handle the response data
        if (data && data.status !== 'success') {
            alert('Cannot quit from the game: ' + data.message);
            return false;
        }
    })
    .catch(error => {
        console.error('Error:', error);
        return false;
    });
}

function requestOrder() {
    console.log('request order...');
    fetch(`${window.location}/request-order`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            if (myPlayer !== null) {
                myPlayer.setOrderLetter(data.letter);
            }
        } else {
            alert('Unknown error: ' + data.message);
        }
    })
    .catch(error => {
        console.error('Error:', error);
    });
}

function requestRack() {
    console.log('request rack...');
    fetch(`${window.location}/request-rack`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            if (myPlayer !== null) {
                updateMyRack(data.rack);
            }
        } else {
            alert('Unknown error: ' + data.message);
        }
    })
    .catch(error => {
        console.error('Error:', error);
    });
}

function revertTiles() {
    const scrabbleRack = document.getElementById('scrabbleRack');

    const placedTiles = document.querySelectorAll('.placed-tile');
    console.log(placedTiles);
    placedTiles.forEach(tile => {
        // Remove the tile from the board
        tile.parentElement.removeChild(tile);

        // Optionally, return the tile to the player's rack
        scrabbleRack.appendChild(tile);

        // Remove the 'placed-tile' class to reset the tile state
        tile.classList.remove('placed-tile');
    });

    selectedTiles = [];
}

function shuffleTiles() {
    const scrabbleRack = document.getElementById('scrabbleRack');
    const tiles = Array.from(scrabbleRack.children);

    // Shuffle the tiles array
    for (let i = tiles.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
    }
    
    // Clear the scrabbleRack and append the shuffled tiles
    scrabbleRack.innerHTML = '';
    tiles.forEach(tile => scrabbleRack.appendChild(tile));
}

function skipTurn() {
    fetch(`${window.location}/skip-turn`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({'gameID': myGame.getGameID(), 'playerID': myPlayer.getPlayerID()})
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {

        } else {
            alert('Unknown error: ' + data.message);
        }
    })
    .catch(error => {
        console.error('Error:', error);
    });
}

function submitWord(tiles=[]) {
    if (myPlayer === null) return;

    if (myPlayer.getPlayerState() !== PlayerState.PLAYING) return;

    if (!verifyWord(selectedTiles)) return;
    
    const tilesJson = JSON.stringify(tiles);

    fetch(`${window.location}/approve-word`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: tilesJson
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            // Update the points box with the calculated points
            if (data.points>0) {
                document.getElementById('myPlayerPoints').textContent = data.points;
                alert('Word verified successfully!');
            } else {
                alert('Word verification failed!');
            }
        } else {
            alert('Unknown error: ' + data.message);
        }
    })
    .catch(error => {
        console.error('Error:', error);
    });
}

function swapLetter() {
    fetch(`${window.location}/swap-letter`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({'gameID': myGame.getGameID(), 'playerID': myPlayer.getPlayerID()})
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {

        } else {
            alert('Unknown error: ' + data.message);
        }
    })
    .catch(error => {
        console.error('Error:', error);
    });
}

// Frontend updates

function updateTentativePoints(points) {
    if (points === null || points === 0) document.getElementById('tentativePoints').textContent = '';
    else document.getElementById('tentativePoints').textContent = ` (${points})`;
}

function updateCurrentPlayerID(playersMeta_) {
    playersMeta_.forEach((player_, index) => {
        if (player_.PLAYER_STATE === PlayerState.PLAYING) {
            currentPlayerID = player_.PLAYER_ID;
        }
    });
}

function updateLeaderboard(playersMeta_) {
    console.log('leaderboard updating...', playersMeta_);
    if (!playersMeta_ || playersMeta_.length === 0) {
        return;
    }

    const tableLeaderboard = document.getElementById('tableLeaderboard');
    tableLeaderboard.innerHTML = ''; // Clear contents

    const fragment = document.createDocumentFragment();

    playersMeta_.forEach((player_, index) => {
        const playerContainer = document.createElement('div');
        playerContainer.classList.add('player-item');

        if (player_.IS_ADMIN) {
            const adminIndicator = document.createElement('span');
            adminIndicator.style.margin = '10px';
            adminIndicator.style.color = 'yellow';
            adminIndicator.textContent = '★';
            adminIndicator.title = 'Admin';
            playerContainer.appendChild(adminIndicator);
        } else {
            const adminIndicator = document.createElement('span');
            adminIndicator.style.margin = '10px';
            adminIndicator.style.color = 'yellow';
            adminIndicator.textContent = ' ';
            adminIndicator.title = ' ';
            playerContainer.appendChild(adminIndicator);
        }

        const playerName = document.createElement('span');
        playerName.style.margin = '10px';
        playerName.textContent = player_.PLAYER_NAME;
        playerContainer.appendChild(playerName);

        const playerPoint = document.createElement('span');
        playerPoint.style.margin = '10px';
        playerPoint.textContent = player_.PLAYER_POINTS;
        playerContainer.appendChild(playerPoint);

        if (player_.PLAYER_STATE === PlayerState.WAITING) {
            const stateIndicator = document.createElement('span');

            playerContainer.appendChild(stateIndicator);
        } else if (player_.PLAYER_STATE === PlayerState.PLAYING) {
            const stateIndicator = document.createElement('span');
            stateIndicator.innerHTML = " \
                <svg class=\"w-6 h-6 text-gray-800 dark:text-white\" aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"> \
                    <path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 8v4l3 3m6-3a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z\"/> \
                </svg> \
            "

            stateIndicator.style.margin = '10px';
            stateIndicator.style.background = 'var(--cell-color)';
            stateIndicator.style.color = 'var(--text-color)';

            playerContainer.appendChild(stateIndicator);
        } else if (player_.PLAYER_STATE === PlayerState.WIN) {

            
        } else if (player_.PLAYER_STATE === PlayerState.LOST) {
            playerName.style.textDecoration = 'line-through';
            playerName.setAttribute('title', 'LOST');
        } else {

        }

        if (myPlayer !== null && myPlayer.getPlayerID() === player_.PLAYER_ID) {
            playerName.style.fontWeight = 'bold';
            playerContainer.style.border = '2px solid white'
            const myPlayerPoints = document.getElementById('myPlayerPoints');
            myPlayerPoints.textContent = `${player_.PLAYER_POINTS}`;
        }

        fragment.appendChild(playerContainer);
    });

    tableLeaderboard.appendChild(fragment); // Batch update for performance
}

function updateMyPlayer(playersMeta_) {
    if (!playersMeta_ || playersMeta_.length === 0) {
        return;
    }

    playersMeta_.forEach((player_, index) => {
        if (myPlayer !== null && myPlayer.getPlayerID() === player_.PLAYER_ID) {
            
            requestRack();
            myPlayer.setPlayerState(player_.PLAYER_STATE)
            myPlayer.setPoints(player_.PLAYER_POINTS)

            // Update player control areas according to its state
            const returnLobbyButton = document.getElementById('returnLobbyButton');
            const requestOrderButton = document.getElementById('requestOrderButton');
            const revertButton = document.getElementById('revertButton');
            const shuffleButton = document.getElementById('shuffleButton');
            const skipTurnButton = document.getElementById('skipTurnButton');

            const scrabbleRack = document.getElementById('scrabbleRack');

            if (myPlayer.getPlayerState() != PlayerState.PLAYING) {
                requestOrderButton.classList.add('blocked');
                revertButton.classList.add('blocked');
                shuffleButton.classList.add('blocked');
                skipTurnButton.classList.add('blocked');
                scrabbleRack.classList.add('blocked');
            } else {
                requestOrderButton.classList.remove('blocked');
                revertButton.classList.remove('blocked');
                shuffleButton.classList.remove('blocked');
                skipTurnButton.classList.remove('blocked');
                scrabbleRack.classList.remove('blocked');
            }

            if (myPlayer.getPlayerState() == PlayerState.WAITING_ORDER) {
                requestOrderButton.classList.remove('blocked');
            }

            // Set points box
            const myPlayerPoints = document.getElementById('myPlayerPoints');
            myPlayerPoints.textContent = `${myPlayer.getPoints()}`;
        }
    });
}

function updateGame(gameMeta) {
    console.log('game updating...', myGame, gameMeta)
    if (myGame === null || gameMeta == null) return;
    myGame.setGameState(gameMeta.GAME_STATE);

    const playerOrderDiv = document.getElementById('playerOrderDiv');
    const rackDiv = document.getElementById('rackDiv');
    const orderTileDiv = document.getElementById('orderTileDiv');
    
    switch (myGame.getGameState()) {
        case (GameState.WAITING_FOR_PLAYERS):
            console.log('GameState.WAITING_FOR_PLAYERS:::');
            playerOrderDiv.style.visibility = 'collapse';
            rackDiv.style.visibility = 'collapse';
            orderTileDiv.style.visibility = 'collapse';
            break;
        case (GameState.PLAYER_ORDER_SELECTION):
            console.log('GameState.PLAYER_ORDER_SELECTION:::');
            playerOrderDiv.style.visibility = 'visible';
            rackDiv.style.visibility = 'collapse';
            orderTileDiv.style.visibility = 'collapse';

            if (myPlayer !== null && myPlayer.getOrderLetter() != null) {
                console.log('GameState.PLAYER_ORDER_SELECTION:::OrderLetterFound');
                const tile = createTile(letter);
                orderTileDiv.appendChild(adminIndicator);
                orderTileDiv.style.visibility = 'visible';
            } //TODO Add else logic here
            break;
        case (GameState.GAME_STARTED):
            console.log('GameState.GAME_STARTED:::');
            playerOrderDiv.style.visibility = 'collapse';
            rackDiv.style.visibility = 'visible';
            orderTileDiv.style.visibility = 'collapse';
            break;
        case (GameState.GAME_OVER):
            console.log('GameState.GAME_OVER:::');
            playerOrderDiv.style.visibility = 'collapse';
            rackDiv.style.visibility = 'collapse';
            orderTileDiv.style.visibility = 'collapse';
            break;
        default:
            break;
    }
}

function updatePlayers(playersMeta_) {
    console.log('players updating...', playersMeta_);

    if (!playersMeta_ || playersMeta_.length === 0) {
        return;
    }

    updateLeaderboard(playersMeta_);
    updateMyPlayer(playersMeta_);
    updateCurrentPlayerID(playersMeta_);
}

function updateBoard(board_) {
    console.log('boards updating...', board_);

}

function updateMyRack(racks_) {
    console.log('racks updating...', racks_);
    const scrabbleRack = document.getElementById('scrabbleRack');

    // Clear the scrabbleRack 
    scrabbleRack.innerHTML = '';
    
    // Empty rack check
    if (!racks_ || Object.keys(racks_).length === 0) return;

    racks_.forEach((letter, count) => {
        for (let i = 0; i < count; i++) {
            let tile = createTile(letter);
            scrabbleRack.appendChild(tile);
        }
    });
}

</script>

</html>
