from io import BytesIO
from typing import List, Callable, Dict, Optional
from collections import defaultdict

from .letter_node import LetterNode

class Dictionary:
    """
    @class Dictionary
    @brief Dictionary using a Directed Acyclic Word Graph (DAWG) in the
    format generated by compress.js
    
    @description Note that the DAWG uses letter indices, and not actual characters, to
    represent code points. To use this dictionary you also need an
    alphabet of code points sorted in the same order as that used to
    generate the DAWG.
    """
    cache = []  # Cache of dictionaries

    def __init__(self, name: str):
        """
        @brief Initialize the dictionary with a name.
        """
        self.root: LetterNode = None  # First node in the dictionary
        self.sequence_roots: Dict[chr, List[LetterNode]] = None  # List of valid start points
        self.name: str = name  # Name of the dictionary

    def load_dawg(self, data: BytesIO) -> 'Dictionary':
        """
        @brief Load a DAWG, as generated by dictionary_compressor.js.
        @description  This is destructive; anything already in the 
        dictionary will be discarded.
        
        @param data: the DAWG data.
        @return: this
        """
        number_of_nodes = int.from_bytes(data.read(4), 'big')

        nodes = []

        for i in range(number_of_nodes):
            letter = int.from_bytes(data.read(4), 'big')
            node = LetterNode(chr(letter))
            node.decode(i, int.from_bytes(data.read(4), 'big'))
            nodes.append(node)

        # Convert node indices to pointers
        for i, node in enumerate(nodes):
            if isinstance(node.next, int):
                node.next = nodes[node.next]
            if isinstance(node.child, int):
                node.child = nodes[node.child]

        self.root = nodes[0]
        return self
    
    def add_links(self) -> 'Dictionary':
        """
        @brief Cross-link nodes in the dictionary with nodes before and
        after them, for fast traversal.

        @return: this
        """
        if self.root is not None:
            self.root.build_lists()
        return self

    def each_word(self, callback: callable):
        """
        @brief Apply the callback to each of the words represented in the DAWG
        (potentially huge!)

        @param callback: function
        """
        if self.root is not None:
            return self.root.each_word("", callback)

    def match(self, chars: str) -> (LetterNode | None):
        """
        @brief Return the LetterNode that matches the last character
        in chars, starting from the root / first character.

        @param chars: characters that may be the root of a word
        @return: node found, or undefined
        """
        if self.root is not None:
            return self.root.match(chars, 0)

    def has_word(self, chars: str) -> bool:
        """
        @brief Check if a word is in the dictionary

        @param chars: a word to check
        @return: true if the word is found, false otherwise
        """
        if not isinstance(chars, str): raise ValueError("chars is not string!")
        
        m = self.root.match(chars, 0) if self.root is not None else None
        return m is not None and m.isEndOfWord

    def find_anagrams(self, the_chars: str) -> List[str]:
        """
        @brief Find anagrams of a set of letters. An anagram is defined as any
        complete (2 or more characters) word that uses all or some of the
        letters passed in.

        @param the_chars: the letters, ' ' for an any-letter wildcard.
        @return: a map of actual words to the letter
                sequence (using ' ' for blanks) that matched.
        """
        the_chars = the_chars.upper()
        if len(the_chars) < 2:
            raise ValueError(f"Dictionary: '{the_chars}' is too short to find anagrams")
        
        # Sort the list of characters for easier debugging
        ac = list(the_chars)
        found_words = {}
        if self.root is not None:
            self.root.find_words_that_use(ac, "", "", found_words)
        return found_words

    def find_hangmen(self, the_chars: str) -> List[str]:
        """
        @brief Find hangman matches for a set of letters. A hangman match is any
        word(s) that match against an ordered set of letters, using a space
        for an any-letter wildcard. For example, "EXAMPLE" is a hangman match
        for "E AM LE".

        @param the_chars: the letters, ' ' for an any-letter wildcard.
        @return: the list of words that matched.
        """
        the_chars = the_chars.upper()
        list_of_matches = []
        if self.root is not None:
            self.root.hangmen(the_chars, 0, "", list_of_matches)
        return list_of_matches

    def create_sequence_roots(self) -> None:
        """
        @brief For each letter of the alphabet, establish a list of valid
        start points, such that at least one start point must match()
        for any sequence of chars, or there can't possibly be a word.
        """
        self.sequence_roots: Dict[str, List[LetterNode]] = {}

        if self.root is not None:
            self.root.each_node(lambda node: self._add_to_sequence_roots(node))
    
    def _add_to_sequence_roots(self, node: LetterNode) -> bool:
        """
        @brief Helper method to add nodes to sequence_roots.

        @return: true after adding node to the sequence roots
        """
        if node.letter not in self.sequence_roots:
            self.sequence_roots[node.letter] = [node]
        else:
            self.sequence_roots[node.letter].append(node)
        return True

    def get_sequence_roots(self, ch: str) -> List[LetterNode]:
        """
        @brief Get a list of the sequence roots for ch. The sequence roots
        are all those nodes that represent the character in any word.
        From a sequence root we can follow post or pre to extend the
        word in either direction.

        @param ch: character to find roots for
        @return: list of the roots
        """
        if self.sequence_roots is None:
            self.create_sequence_roots()
        return self.sequence_roots.get(ch, [])

    def _add_word(self, word: str) -> bool:
        """
        @brief Do the work of adding a word, but don't do anything about
        pre-/post- links or sequence roots.

        @param word: Word to be added to the root
        @return: true if word added to the root, false otherwise
        """
        if len(word) == 0:
            return False
        if self.root is None:
            self.root = LetterNode(word[0])
        elif self.has_word(word):
            return False
        
        self.root.add(word)
        return True

    def add_word(self, word: str):
        """
        @brief Add a word to the dictionary. No attempt is made at compression.
        Note that previously retrieved sequence roots will no longer
        be valid after the word is added and will need to be recomputed.
        Note that we support single character words here, but
        word games are limited to 2 letter or more. It's up to
        the caller to enforce such constraints.

        @return: true if the word needed to be added, false if it was empty or already there.
        """
        if self._add_word(word):
            # Don't recreate, that will be done on demand
            if self.sequence_roots is not None:
                self.sequence_roots = None
            
            if self.root is not None:
                self.root.build_lists()
            return True
        return False

    def find_sequence(self, seq: str) -> Optional['LetterNode']:
        """
        @brief Find start node for the character sequence in the sequence
        index i.e. it forms a valid sub-part of a word in the
        dictionary. This way we can quickly eliminate sequences
        such as "QX" which are never found in the dictionary. Note
        that we don't have any way to reproduce the words that the
        sequence is a valid part of; that's not the point, this is
        intended to help eliminate invalid sequences when extending
        a word backwards from a seed letter.

        @param seq: letter sequence
        @return: node found, or undefined 
        """
        if self.sequence_roots is None:
            self.create_sequence_roots()
        
        roots: List[LetterNode] = self.sequence_roots.get(seq[0], [])
        if roots is None or len(roots) <= 0:
            raise ValueError(f"Dictionary: '{seq}' has no roots")
        for root in roots:
            if root.match(seq, 0):
                return root
        return None

    def has_sequence(self, seq: str) -> bool:
        """
        @brief Return true if a start node for the character sequence is found
        in the sequence index i.e. it forms a valid sub-part of a word
        in the dictionary. This way we can quickly eliminate sequences
        such as "QX" which are never found in the dictionary. Note that
        we don't have any way to reproduce the words that the sequence
        is a valid part of; that's not the point, this is intended to help
        eliminate invalid sequences when extending a word backwards from
        a seed letter.

        @param seq: letter sequence
        @return: true if a start node exists
        """
        return self.find_sequence(seq) is not None
